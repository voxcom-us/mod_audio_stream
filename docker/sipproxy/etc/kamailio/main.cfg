debug=2
log_stderror=no
server_header="Server: siprouter"
user_agent_header="User-Agent: siprouter"
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
fork=yes
mhomed=0
tcp_accept_no_cl=yes
tcp_no_connect=0
enable_tls=no
auto_aliases=no

mpath="/usr/lib/kamailio/modules/"

loadmodule "db_sqlite.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "cfgutils.so"
loadmodule "sl.so"
loadmodule "outbound.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "nathelper.so"
loadmodule "permissions.so"
loadmodule "path.so"
loadmodule "rtpengine.so"
loadmodule "dispatcher.so"
loadmodule "json.so"
loadmodule "xhttp.so"
loadmodule "stun.so"
loadmodule "jsonrpcs.so"

# ----------------- setting module-specific parameters ---------------

# ----- ctl params -----
modparam("ctl", "binrpc_struct_max_body_size", 64)

# ----- rr params -----
modparam("rr", "append_fromtag", 0)

# ----- outbound params -----
modparam("outbound", "force_outbound_flag", 1)

# ----- nathelper params -----
modparam("nathelper", "received_avp", "$avp(s:rcv)")

# ----- permissions params -----
modparam("permissions", "db_url", "sqlite:////etc/kamailio/kamailio.db")
modparam("permissions", "db_mode", 1)

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:localhost:2223")

# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "hash_pvar", "$avp(domain)")
modparam("dispatcher", "ds_hash_size", 8)
modparam("dispatcher", "ds_ping_interval", 20)
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=480;code=404")
modparam("dispatcher", "ds_ping_from", "sip:siprouter@local.sipproxy")

# ----- cfgutils params -----
modparam("cfgutils", "initial_probability", 50) # use 50% probability to determine either flowroute or bandwidth for outbound

# ----- sanity params -----
modparam("sanity", "default_checks", 487) # defaults without proxy-require

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 7)


request_route {
	# per request initial checks
	route(REQINIT);

	if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

	if (is_method("BYE|CANCEL")) {
		rtpengine_delete();
	}

	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	route(WITHINDLG);

	route(INVITE);
}

# Per SIP request initial checks
route[REQINIT] {
	if (!mf_process_maxfwd_header("10")) {
		xlog("L_WARN", "[$ci][$rm]: too many hops");
		send_reply("483", "Too Many Hops");
		exit;
	}
	if (!sanity_check()) {
		xlog("L_WARN", "[$ci][$rm]: message is insane");
		exit;
	}
	if (is_method("PUBLISH")) {
		xlog("L_WARN", "[$ci][$rm]: dropping unsupported message [$rm] from user-agent [$ua]");
		exit;
	}
}

route[WITHINDLG] {
	if (!has_totag()) {
		return;
	}
	if (loose_route()) {
		if ($du == "") {
			if (!handle_ruri_alias()) {
				xlog("L_ERR", "[$ci][$rm]: bad alias <$ru>");
				sl_send_reply("400", "Bad Request");
				exit;
			}
		}
		route(RELAY);
	} else {
		if (is_method("NOTIFY")) {
			route(RELAY);
		}
		if (is_method("ACK")) {
			if (t_check_trans()) {
				t_relay();
				exit;
			} else {
				exit;
			}
		}
		sl_send_reply("404","Not here");
	}
	exit;
}

route[INVITE] {
	if (!is_method("INVITE")) {
		return;
	}
	record_route();
	$avp(hash) = $fd;
	$var(set_id) = 0;
	xlog("L_INFO", "[$ci][$rm]: dispatching [$rU] using hash [$avp(hash)] with setid [$var(set_id)]");
	if (!ds_select_dst("$var(set_id)", "7")) {
		xlog("L_WARN", "[$ci][$rm]: could not send [$rU] to destination setid [$var(set_id)]");
		send_reply("404", "No destination");
		exit;
	}
	route(RELAY);
}

route[NAT_TEST_AND_CORRECT] {
	force_rport();
	if (is_method("INVITE|PRACK|NOTIFY|REFER|UPDATE|BYE") && $ct != $null) {
		if (!set_contact_alias()) {
			xlog("L_WARN", "[$ci][$rm]: could not add contact alias [$rm] - [$rs] [$Rp]");
		}
	}
}

route[RELAY] {
	if ($Rp == "4060") {
		xlog("L_INFO", "[$ci][$rm]: routing request [$rm] from private [$sp] [$Rp]");
		if (has_body("application/sdp") && !rtpengine_offer("direction=private direction=public ICE=remove")) {
			xlog("L_WARN", "$ci|could not execute rtpengine offer from private interface to public interface");
		}
	} else {
		xlog("L_INFO", "[$ci][$rm]: routing request [$rm] from public [$sp] [$Rp]");
		if (has_body("application/sdp") && !rtpengine_offer("direction=public direction=private ICE=remove")) {
			xlog("L_WARN", "$ci|could not execute rtpengine offer from public interface to private interface");
		}
		force_send_socket(SIP_INTERNAL_SOCKET);
	}

	if (!t_relay()) {
		xlog("L_WARN", "[$ci][$rm]: could not relay [$rm] Request-URI [$ru] From-URI [$fu] To-URI [$tu]");
		sl_reply_error();
	}
	exit;
}

reply_route {
	if ($Rp == "4060") {
		if (has_body("application/sdp") && !rtpengine_answer("direction=private direction=public ICE=remove")) {
			xlog("L_WARN", "$ci|could not execute rtpengine answer on reply [$rm] from private interface to public interface");
		}
		return;
	}
	xlog("L_INFO", "[$ci][$rm]: routing reply [$rm] to sipproxy [$Rp]");
	route(NAT_TEST_AND_CORRECT);
	if (has_body("application/sdp") && !rtpengine_answer("direction=public direction=private ICE=remove")) {
		xlog("L_WARN", "$ci|could not execute rtpengine answer on reply [$rm] from public interface to private interface");
	}
	force_send_socket(SIP_INTERNAL_SOCKET);
}

event_route[xhttp:request] {
	if ($Rp == 8000 && $hu =~ "^/35100937-6a46-43db-8b88-09c717798412") {
		jsonrpc_dispatch();
		exit;
	}
	xhttp_reply("404", "Not Found", "", "");
}
